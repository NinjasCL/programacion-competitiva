= 2114A - A. Square Year

- L√≠mite de tiempo por prueba: 1 segundo.
- L√≠mite de memoria por prueba: 256 megabytes.
- https://codeforces.com/problemset/problem/2114/A[C√≥digo Original].
- Fecha: 16/09/2025.
- Dificultad: üç∞ (800)
- Tags: binary search, brute force, math

Se puede notar el siguiente hecho matem√°tico notable: el n√∫mero asciimath:[2025] puede representarse como asciimath:[(20+25)^2].

Se te da un a√±o representado por una cadena asciimath:[s], que consta exactamente de *4* caracteres. Por lo tanto, se permiten ceros a la izquierda en la representaci√≥n del a√±o. Por ejemplo, asciimath:["0001"], asciimath:["0185"] y asciimath:["1375"] son representaciones v√°lidas de a√±os.

Necesitas expresarlo en la forma asciimath:[(a + b)^2], donde asciimath:[a] y asciimath:[b] son enteros no negativos, o determinar que es imposible.

Por ejemplo, si asciimath:[s = "0001"], puedes elegir asciimath:[a = 0], asciimath:[b = 1], y escribir el a√±o como asciimath:[(0+1)^2 = 1].

*Entrada*

La primera l√≠nea de la entrada contiene un solo entero asciimath:[t] (asciimath:[1 ‚â§ t ‚â§ 10^4]): el n√∫mero de casos de prueba.

Las l√≠neas siguientes describen los casos de prueba.

La √∫nica l√≠nea de cada caso de prueba contiene una cadena asciimath:[s], que consta de exactamente *4* caracteres. Cada car√°cter es un d√≠gito del asciimath:[0] al asciimath:[9].

*Salida*

En una l√≠nea separada para cada caso de prueba, imprime:

- Dos n√∫meros asciimath:[a] y asciimath:[b] (asciimath:[a, b ‚â• 0]) tales que asciimath:[(a + b)^2 = s], si existen. 
- Si hay m√∫ltiples pares adecuados, puedes imprimir cualquiera de ellos. asciimath:[-1] de lo contrario.

*Ejemplo*

|====
|Input | Output

a| 
[source, text]
----
5
0001
1001
1000
4900
2025
----
a|
[source, text]
----
0 1
-1
-1
34 36
20 25
----

|====

== Soluci√≥n O(1) en Python

Para esta soluci√≥n utilizando matem√°ticas (Estilo Ruso) simplemente debemos
despejar los valores de asciimath:[a] y asciimath:[b] para que se cumpla la ecuaci√≥n
asciimath:[(a + b)^2 = "a√±o"].

El ejercicio nos pide cualquier tipo de suma de valores, simplemente debe haber un par 
n√∫meros que cumplan la ecuaci√≥n. Si asumimos que el valor de asciimath:[a = 0] simplificamos la ecuaci√≥n a 

asciimath:[b^2 = "a√±o"]. 

Entonces podemos obtener el valor de asciimath:[b] con:

asciimath:[b = sqrt("a√±o")]. 

Esto nos permitir√° saber el valor de asciimath:[b], pero estamos trabajando solo con n√∫meros enteros, 
por lo que se pierde precisi√≥n si la ra√≠z del a√±o es un n√∫mero con decimales. Estos nos obliga a verificar el valor de asciimath:[b] y que deba ser igual al a√±o si lo elevamos al cuadrado.

Es decir se debe cumplir lo siguiente: asciimath:[b^2 = "a√±o" == b = sqrt("a√±o")].

Una vez obtenidos estos valores, solamente queda mostrar el par asciimath:[(0, b)] y asciimath:[-1]
si no se encuentra un valor de asciimath:[b] que cumpla la restricci√≥n.

[source, python]
----
include::example$2114a-square-year/solution-o(1).py[]
----