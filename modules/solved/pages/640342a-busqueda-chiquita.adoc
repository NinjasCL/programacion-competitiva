= 640342A - B√∫squeda Chiquita

- L√≠mite de tiempo por prueba: 2 segundos.
- L√≠mite de memoria por prueba: 4 megabytes.
- https://codeforces.com/gym/640342[C√≥digo Original].
- Fecha: 4/10/2025.
- Autor: Gabriel Carmona, TCP 2025
- Tipo: USA üá∫üá∏
- Dificultad: ü§Ø (2900)
- Tags: implementation

[NOTE]
====
NOTA LA INUSUAL MEMORIA L√çMITE DEL PROBLEMA
====

¬°Se abrieron las inscripciones para el Torneo Chileno de Programaci√≥n (TCP)! Muchas personas se
registraron para participar. Dentro de la organizaci√≥n est√° el comit√© de medici√≥n, en el cual trabaja
Javier. Su tarea es anotar las alturas de los participantes para poder ordenarlos en la foto oficial del TCP.

Mart√≠n, encargado de acomodar a las personas en la foto, necesita consultar cu√°ntos participantes tienen
altura menor que cierta altura. Sin embargo, tiene memoria de pez dorado, as√≠ que a veces pregunta
varias veces por la misma altura.

Javier, consciente de esto, quiere ayudarlo con un sistema de consultas eficiente. Pero como tiene
problemas de visi√≥n, necesita que el sistema guarde todas las alturas usando poco espacio.
A √∫ltimo minuto, Javier se rompi√≥ las manos y no puede dise√±ar el sistema. Por eso te pide ayuda.

*Entrada*

La primera l√≠nea contiene dos enteros asciimath:[n] y asciimath:[q] (asciimath:[1 ‚â§ n ‚â§ 3 * 10^6], asciimath:[1 ‚â§ q ‚â§ 10^6]), 
correspondiente a la cantidad de personas inscritas al TCP y la cantidad de consultas realizadas por Mart√≠n.

Le sigue una segunda l√≠nea que contiene asciimath:[n] enteros separados por un espacio, cada entero tiene valor entre
asciimath:[1] y asciimath:[3 * 10^6]. Cada entero corresponde a la altura de un participante. Se asegura que todas las alturas son
distintas.

Finalmente, le siguen asciimath:[q] l√≠neas, donde cada l√≠nea contiene un entero correspondiente a la altura consultada
por Mart√≠n. Cada altura consultada puede tener valor entre asciimath:[1] y asciimath:[3 * 10^6].

*Salida*

Por cada consulta, se debe imprimir una l√≠nea con un entero, correspondiente a la cantidad de alturas
menor que la altura consultada.

*Ejemplo*

|====
|Input | Output

a| 
[source, text]
----
10 4 
7 2 3 82 70 66 8 13 14 11
1
69
8
100
----
a|
[source, text]
----
0
8
3
10
----
|====

[NOTE]
====
La entrada/salida de este problema es muy grande, por lo que se recomienda usar t√©cnicas de
entrada/salida r√°pida.

En C++: al inicio del programa main deber√°n escribir: 

- `std::ios::sync_with_stdio(false);`
- `std::cin.tie(nullptr);`
====

== Fuerza Bruta en Python

En este intento se implementa sin tener en consideraci√≥n los l√≠mites de 4mb.
Por lo que no es una soluci√≥n aceptada. Sin embargo nos permite obtener
una aproximaci√≥n al resultado buscado.

Primero se debe ordenar la lista y luego utilizando b√∫squeda binaria se puede encontrar
la cantidad de elementos menores al valor buscado.

[source, python]
----
include::example$640342a-busqueda-chiquita/solution.py[]
----

== Soluci√≥n en C++

La soluci√≥n requiere de varias diferentes t√©cnicas y conocimientos de operaciones binarias.
Ya que se debe reducir la cantidad de memoria usada, no se puede utilizar arreglos grandes
ni operaciones costosas como un `sort`.

Primero la representaci√≥n de 64 bits de un n√∫mero. Cualquier n√∫mero permite ser representado
en 64 posiciones, es decir un arreglo de 64 elementos que pueden ser `0` o `1`.

Si usamos python podemos realizar esta representaci√≥n en formato binario con un padding de ceros
hasta llenar 64 posiciones.

[source, python]
----
>>> format(1, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000000000000001'

>>> format(1024, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000010000000000'

>>> format(6502, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000001100101100110'
----

Lo que se tiene que hacer es que se debe almacenar la cantidad de n√∫meros anteriores
al n√∫mero buscado, sin ordenarlos. Para esto hay que saber c√≥mo funciona la representaci√≥n binaria. 
Se demostrar√° con los n√∫meros del 1 al 10. 

[source, python]
----
>>> format(1, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000000000000001'

>>> format(2, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000000000000010'

>>> format(3, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000000000000011'

>>> format(4, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000000000000100'

>>> format(5, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000000000000101'

>>> format(6, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000000000000110'

>>> format(7, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000000000000111'

>>> format(8, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000000000001000'

>>> format(9, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000000000001001'

>>> format(10, 'b').zfill(64)
'0000000000000000000000000000000000000000000000000000000000001010'
----

Supongamos que tenemos la siguiente lista de n√∫meros: 5, 7, 1, 10
y queremos saber c√∫antos n√∫meros hay antes del n√∫mero 8 en la lista.
La respuesta correcta ser√≠a 3 (1, 5 y 7). Por lo que debemos ver sus representaciones binarias.

- 5: `0101`
- 7: `0111`
- 1: `0001`
- 10: `1010`
- 8: `1000`

Primero debemos clasificar los n√∫meros en que p√°gina del total de 64 posiciones est√°n almacenados, 
es decir solo debemos almacenar el contador de la p√°gina y su posici√≥n dentro de ella, no del n√∫mero en s√≠.

Para saber la p√°gina debemos dividir el n√∫mero por 64.

[source, python]
----
# // en python es divisi√≥n por integer
>>> 1024 // 64 
16
>>> 1025 // 64
16
>>> 1026 // 64
16
>>> 1098 // 64
17
>>> 1099 // 64
17
----

Si buscamos los n√∫meros de la lista por p√°gina encontraremos que est√°n todos 
en la misma p√°gina, por lo que necesitamos tener otra informaci√≥n adicional.

[source, python]
----
>>> 5 // 64
0
>>> 7 // 64
0
>>> 1 // 64
0
>>> 10 // 64
0
>>> 8 // 64
0
----

Tambi√©n debemos saber en qu√© posici√≥n dentro de la p√°gina, est√° el n√∫mero buscado.
Para esto utilizamos el operador m√≥dulo y obtenemos el restante.

[source, python]
----
>>> 1024 % 64
0
>>> 1025 % 64
1
>>> 1026 % 64
2
>>> 1098 % 64
10
>>> 1099 % 64
11
----

Para el caso buscado la posici√≥n dentro de la p√°gina es el mismo n√∫mero, 
pero esto puede variar como se demostr√≥ en el ejemplo anterior.

[source, python]
----
>>> 5 % 64
5
>>> 7 % 64
7
>>> 1 % 64
1
>>> 10 % 64
10
>>> 8 % 64
8
----

Ahora es necesario contar la cantidad de sub total de n√∫meros que est√°n en cada p√°gina.
Esto contar√≠a el "peso" de cada p√°gina seg√∫n los n√∫meros entregados.

Para saber esto necesitamos usar la operacion bitwise `<<` la cual permite multiplicar
un n√∫mero por su potencia de 2 de forma eficiente. Es decir `1 << n` es lo mismo que decir asciimath:[1 * 2^n].
asciimath:[n] en este caso ser√≠a el asciimath:["n√∫mero" - 1].

Para obtener el "peso" que tendr√° cada n√∫mero solamente necesitamos multiplicar por un factor de 2 (por ser binario).

[source, python]
----
>>> 1 << ((1 - 1) % 64)
1
>>> 1 << ((2 - 1) % 64)
2
>>> 1 << ((3 - 1) % 64)
4
>>> 1 << ((4 - 1) % 64)
8
>>> 1 << ((5 - 1) % 64)
16
>>> 1 << ((6 - 1) % 64)
32
>>> 1 << ((7 - 1) % 64)
64
>>> 1 << ((8 - 1) % 64)
128
>>> 1 << ((9 - 1) % 64)
256
>>> 1 << ((10 - 1) % 64)
512
----

Por lo que necesitar√≠amos las siguientes funciones:

[source, python]
----
def pagina_numero(numero):
  x = numero - 1
  pagina = x // 64 
  posicion = x % 64
  return (pagina, posicion)

def peso_posicion(posicion):
  return 1 << posicion

def acumular_pagina(acc, numero):
  pagina, posicion = pagina_numero(numero)
  peso = peso_posicion(posicion)
  acc[pagina] += peso
  return acc
----
