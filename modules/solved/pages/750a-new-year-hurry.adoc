= New Year and Hurry

- L칤mite de tiempo por prueba: 1 segundo.
- L칤mite de memoria por prueba: 256 megabytes.
- https://codeforces.com/problemset/problem/750/A[C칩digo Original].
- Fecha: 13/09/2025.
- Dificultad: 游꼻 (800)
- Tags: binary search, brute force, implementation, math

Limak va a participar en un concurso el 칰ltimo d칤a de 2016. El concurso empezar치 a las _20:00_ y durar치 *cuatro horas*, exactamente hasta la medianoche. Habr치 asciimath:[n] problemas, ordenados por dificultad, es decir, el problema asciimath:[1] es el m치s f치cil y el problema asciimath:[n] es el m치s dif칤cil. Limak sabe que le tomar치 asciimath:[5췅i] minutos resolver el problema asciimath:[i]-칠simo.

Los amigos de Limak organizan una fiesta de A침o Nuevo y 칠l quiere llegar a la fiesta a la medianoche o antes. Necesita asciimath:[k] minutos para llegar desde su casa, donde participar치 en el concurso primero.

La pregunta es: 쮺u치ntos problemas puede resolver Limak si quiere llegar a la fiesta a tiempo?


== Soluci칩n O(n) en C++

Esta soluci칩n es de fuerza bruta. Probando todos los elementos posibles.

[source, cpp]
----
include::example$750a-new-year-hurry/solution-o(n).cpp[]
----


== Soluci칩n O(1) en C++

Esta soluci칩n utiliza las propiedades de las progresiones artim칠ticas
para obtener el resultado.

[source, cpp]
----
include::example$750a-new-year-hurry/solution-o(1).cpp[]
----

== Soluci칩n O(logn) en Python

La soluci칩n corresponde a encontrar la respuesta
utilizando b칰squeda binaria entre todo el espectro de candidatos posibles (t칠cnica de Binary Search in answer).

*Paso 1*

Sabemos que el tiempo m치ximo ser치 de 4 horas - el tiempo que tome llegar a la fiesta. Es decir asciimath:[240 - k] minutos (siendo asciimath:[240] los minutos que tiene 4 horas). 

El desaf칤o consiste en averiguar la cantidad m치xima de problemas que se pueden resolver dentro del tiempo disponible.

[source, python]
----
def main():
    n, k = map(int, input().split())
    available_time = 240 - k
    print(find_max_quantity_of_solved_problems(n, available_time))

if __name__ == "__main__":
  main()
----

*Paso 2*

Ahora se obtiene el m치ximo y el m칤nimo dentro de la funci칩n que aplicar치 la b칰squeda binaria. Estos vienen siendo la cantidad de problemas posibles a resolver. Como m칤nimo resolveremos cero y como m치ximo la cantidad total de problemas.

Notar que si el candidato es v치lido, tenemos que averiguar si el siguiente candidato es mejor (m치s problemas posibles a resolver).
Por lo que debemos aumentar el l칤mite m칤nimo. Caso contrario
deberemos reducir el l칤mite m치ximo.

[source, python]
----
def find_max_quantity_of_solved_problems(total_problem_count, available_time):
    low = 0
    high = total_problem_count

    answer = high

    while low <= high:
        candidate = low + (high - low) // 2

        if candidate_is_valid(candidate, available_time):
            answer = candidate
            low = candidate + 1
        else:
            high = candidate - 1
            
    return answer
----

*Paso 3*

Luego se define la funci칩n para validar el candidato. Si el tiempo total necesario para resolver la cantidad de problemas sugeridas por el candidato es menor al tiempo disponible, entonces es un candidato v치lido.
El range de asciimath:[i] es m칤nimo es asciimath:[1] y m치ximo la cantidad de soluciones del candidato + una adicional para compensar el contador desde cero.

[source, python]
----
def candidate_is_valid(quantity_to_solve, available_time):
  used_time = 0
  for i in range(1, quantity_to_solve + 1):
    used_time += i * 5
  return used_time <= available_time
----

*Soluci칩n*

Juntando todo el c칩digo se tiene la siguiente soluci칩n.

[source, python]
----
include::example$750a-new-year-hurry/solution-bs.py[]
----