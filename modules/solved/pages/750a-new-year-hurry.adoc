= 750A - New Year and Hurry

- L√≠mite de tiempo por prueba: 1 segundo.
- L√≠mite de memoria por prueba: 256 megabytes.
- https://codeforces.com/problemset/problem/750/A[C√≥digo Original].
- Fecha: 13/09/2025.
- Dificultad: üç∞ (800)
- Tags: binary search, brute force, implementation, math

Limak va a participar en un concurso el √∫ltimo d√≠a de 2016. El concurso empezar√° a las _20:00_ y durar√° *cuatro horas*, exactamente hasta la medianoche. Habr√° asciimath:[n] problemas, ordenados por dificultad, es decir, el problema asciimath:[1] es el m√°s f√°cil y el problema asciimath:[n] es el m√°s dif√≠cil. Limak sabe que le tomar√° asciimath:[5¬∑i] minutos resolver el problema asciimath:[i]-√©simo.

Los amigos de Limak organizan una fiesta de A√±o Nuevo y √©l quiere llegar a la fiesta a la medianoche o antes. Necesita asciimath:[k] minutos para llegar desde su casa, donde participar√° en el concurso primero.

La pregunta es: ¬øCu√°ntos problemas puede resolver Limak si quiere llegar a la fiesta a tiempo?

*Entrada*

Los par√°metros de entrada son dos enteros asciimath:[n] y asciimath:[k] (asciimath:[1 ‚â§ n ‚â§ 10], asciimath:[1 ‚â§ k ‚â§ 240]): el n√∫mero de problemas en el concurso y la cantidad de minutos que Limak necesita para llegar a la fiesta desde su casa.

*Salida*

Imprime un entero, que representa el n√∫mero m√°ximo posible de problemas que Limak puede resolver para poder llegar a la fiesta a medianoche o antes.

*Ejemplo*

|====
|Input | Output

a| 
[source, text]
----
3 222
----
| 2

a| 
[source, text]
----
4 190
----
| 4

a| 
[source, text]
----
7 1
----
| 7

|====

== Soluci√≥n O(n) en C++

Esta soluci√≥n es de fuerza bruta. Probando todos los elementos posibles.

[source, cpp]
----
include::example$750a-new-year-hurry/solution-o(n).cpp[]
----


== Soluci√≥n O(1) en C++

Para poder resolver este problema se debe pensar matem√°ticamente (Estilo _Ruso_).
En primer lugar tenemos una progresi√≥n de t√©rminos que se deben sumar
para obtener el tiempo total necesario para resolver la cantidad de problemas
dado por asciimath:[n]. Agradecimientos a _Marcelo Guzman (13/09/2025)_ por detallar el 
an√°lisis matem√°tico.

Ejemplo: 

- asciimath:[n = 3]
- asciimath:["demora" = sum_(i=1)^n i*5 = 30]

Entonces al tener una progresi√≥n de elementos que se deben sumar, se puede
usar lo que se conoce como *progresi√≥n aritm√©tica*.

La *progresi√≥n aritm√©tica* tiene dos f√≥rmulas que pueden ser usadas
dependiendo de la cantidad de informaci√≥n que se tenga disponible.

- Se conoce el primer y √∫ltimo t√©rmino de la progresi√≥n: asciimath:[S_n = n/2 * (a + l) ]
- Solo se conoce el primer t√©rmino de la progresi√≥n: asciimath:[S_n = n/2 * (2a + (n-1)d)]

Seg√∫n la informaci√≥n del enunciado se conoce los siguientes datos:

- El tiempo disponible:  asciimath:[240 - k].
- La cantidad total de problemas: asciimath:[n].

Como la progresi√≥n tiene una f√≥rmula constante de asciimath:[sum_(i=1)^n i*5]. Podemos calcular el primer
y √∫ltimo t√©rmino de la progresi√≥n. El primer t√©rmino siempre ser√° asciimath:[5], debido a que la cantidad
de problemas siempre parte en asciimath:[1]. El √∫ltimo t√©rmino siempre ser√° asciimath:[n * 5], debido a que la cantidad
m√°xima siempre ser√° el total de problemas multiplicado por asciimath:[5].

Por lo que la f√≥rmula para calcular el total de tiempo dado un valor asciimath:[n] ser√°: 

asciimath:[S_n = (n * (5 + (n * 5)))/2]

asciimath:[S_n = (5n + 5n^2)/2]

Tenemos el valor que tomar√° resolver asciimath:[n] cantidad de problemas, sin embargo 
debemos verificar que esto sea menor o igual al tiempo disponible. La pregunta a responder
es: ¬øCu√°l es el valor de asciimath:[x] cantidad de problemas de modo que sea menor o igual al tiempo disponible?.

asciimath:[S_n = (5x + 5x^2)/2 <= "disponible"] 

Desarrollamos la ecuaci√≥n.

asciimath:[S_n = (5x + 5x^2) <=  (2 * "disponible)"]


asciimath:[S_n = 5 * (x + x^2) <=  (2 * "disponible")]

asciimath:[S_n = x + x^2 <=  (2 * "disponible")/5]

Como asciimath:["disponible"] es un valor constante, obtenemos una ecuaci√≥n cuadr√°tica.

asciimath:[S_n = x^2 + x - (2 * "disponible")/5 <=  0]

Solo necesitamos despejar asciimath:[x] con la f√≥rmula de ecuaci√≥n 
cuadr√°tica asciimath:[x=(-b +- sqrt(b^2 - 4ac))/(2a)].

Siendo los siguientes los valores a reemplazar en la ecuaci√≥n:

- asciimath:[a = 1] (Coeficiente cuadr√°tico asciimath:[x^2])
- asciimath:[b = 1] (Coeficiente lineal asciimath:[x])
- asciimath:[c = (-2 * "disponible")/5] (Constante o t√©rmino independiente).

Por lo que la ecuaci√≥n quedan dos posibles resultados.

- Soluci√≥n Positiva: asciimath:[x=(-1 + sqrt((-1)^2 - 4 * 1 * c))/(2*1)]
- Soluci√≥n Negativa: asciimath:[x=(-1 - sqrt((-1)^2 - 4 * 1 * c))/(2*1)]

Como estamos contando minutos, estos no pueden ser negativos. Por lo que 
solamente consideramos con la *Soluci√≥n Positiva*.

asciimath:[x=(-1 + sqrt((-1)^2 - 4 * 1 * c))/(2*1)]

asciimath:[x=(-1 + sqrt(1 - 4c))/2]

Reemplazamos asciimath:[c] por el valor "disponible"

asciimath:[x=(-1 + sqrt(1 - 4 * ((-2 * "disponible")/5)))/2]

asciimath:[x=(-1 + sqrt(1 + (8 * "disponible")/5))/2]

Finalmente, la soluci√≥n no puede ser mayor a la cantidad m√°xima asciimath:[n] de ejercicios
disponibles. Por lo que debemos aplicar una operaci√≥n de l√≠mite m√°ximo. Conocida como *clamp*
o *abrazadera* (`clamp(x, min, max)`).

asciimath:["respuesta" = min(max(x, 0), n)]


[source, cpp]
----
include::example$750a-new-year-hurry/solution-o(1).cpp[]
----

== Soluci√≥n O(logn) en Python

La soluci√≥n corresponde a encontrar la respuesta
utilizando b√∫squeda binaria entre todo el espectro de candidatos posibles (t√©cnica de Binary Search in answer).

*Paso 1*

Sabemos que el tiempo m√°ximo ser√° de 4 horas - el tiempo que tome llegar a la fiesta. Es decir asciimath:[240 - k] minutos (siendo asciimath:[240] los minutos que tiene 4 horas). 

El desaf√≠o consiste en averiguar la cantidad m√°xima de problemas que se pueden resolver dentro del tiempo disponible.

[source, python]
----
def main():
    n, k = map(int, input().split())
    available_time = 240 - k
    print(find_max_quantity_of_solved_problems(n, available_time))

if __name__ == "__main__":
  main()
----

*Paso 2*

Ahora se obtiene el m√°ximo y el m√≠nimo dentro de la funci√≥n que aplicar√° la b√∫squeda binaria. Estos vienen siendo la cantidad de problemas posibles a resolver. Como m√≠nimo resolveremos cero y como m√°ximo la cantidad total de problemas.

Notar que si el candidato es v√°lido, tenemos que averiguar si el siguiente candidato es mejor (m√°s problemas posibles a resolver).
Por lo que debemos aumentar el l√≠mite m√≠nimo. Caso contrario
deberemos reducir el l√≠mite m√°ximo.

[source, python]
----
def find_max_quantity_of_solved_problems(total_problem_count, available_time):
    low = 0
    high = total_problem_count

    answer = high

    while low <= high:
        candidate = low + (high - low) // 2

        if candidate_is_valid(candidate, available_time):
            answer = candidate
            low = candidate + 1
        else:
            high = candidate - 1
            
    return answer
----

*Paso 3*

Luego se define la funci√≥n para validar el candidato. Si el tiempo total necesario para resolver la cantidad de problemas sugeridas por el candidato es menor al tiempo disponible, entonces es un candidato v√°lido.
El range de asciimath:[i] es m√≠nimo es asciimath:[1] y m√°ximo la cantidad de soluciones del candidato + una adicional para compensar el contador desde cero.

[source, python]
----
def candidate_is_valid(quantity_to_solve, available_time):
  used_time = 0
  for i in range(1, quantity_to_solve + 1):
    used_time += i * 5
  return used_time <= available_time
----

*Soluci√≥n*

Juntando todo el c√≥digo se tiene la siguiente soluci√≥n.

[source, python]
----
include::example$750a-new-year-hurry/solution-bs.py[]
----