= New Year and Hurry

- Límite de tiempo por prueba: 1 segundo.
- Límite de memoria por prueba: 256 megabytes.
- https://codeforces.com/problemset/problem/750/A[Código Original].
- Fecha: 13/09/2025.
- Dificultad: 🍰 (800)
- Tags: binary search, brute force, implementation, math

Limak va a participar en un concurso el último día de 2016. El concurso empezará a las _20:00_ y durará *cuatro horas*, exactamente hasta la medianoche. Habrá asciimath:[n] problemas, ordenados por dificultad, es decir, el problema asciimath:[1] es el más fácil y el problema asciimath:[n] es el más difícil. Limak sabe que le tomará asciimath:[5·i] minutos resolver el problema asciimath:[i]-ésimo.

Los amigos de Limak organizan una fiesta de Año Nuevo y él quiere llegar a la fiesta a la medianoche o antes. Necesita asciimath:[k] minutos para llegar desde su casa, donde participará en el concurso primero.

La pregunta es: ¿Cuántos problemas puede resolver Limak si quiere llegar a la fiesta a tiempo?


== Solución O(n) en C++

Esta solución es de fuerza bruta. Probando todos los elementos posibles.

[source, cpp]
----
include::example$750a-new-year-hurry/solution-o(n).cpp[]
----


== Solución O(1) en C++

Para poder resolver este problema se debe pensar matemáticamente (Estilo _Ruso_).
En primer lugar tenemos una progresión de términos que se deben sumar
para obtener el tiempo total necesario para resolver la cantidad de problemas
dado por asciimath:[n].

Ejemplo: 

- asciimath:[n = 3]
- asciimath:["demora" = sum_(i=1)^n i*5 = 30]

Entonces al tener una progresión de elementos que se deben sumar, se puede
usar lo que se conoce como *progresión aritmética*.

La *progresión aritmética* tiene dos fórmulas que pueden ser usadas
dependiendo de la cantidad de información que se tenga disponible.

- Se conoce el primer y último término de la progresión: asciimath:[S_n = n/2 * (a + l) ]
- Solo se conoce el primer término de la progresión: asciimath:[S_n = n/2 * (2a + (n-1)d)]

Según la información del enunciado se conoce los siguientes datos:

- El tiempo disponible:  asciimath:[240 - k].
- La cantidad total de problemas: asciimath:[n].

Como la progresión tiene una fórmula constante de asciimath:[sum_(i=1)^n i*5]. Podemos calcular el primer
y último término de la progresión. El primer término siempre será asciimath:[5], debido a que la cantidad
de problemas siempre parte en asciimath:[1]. El último término siempre será asciimath:[n * 5], debido a que la cantidad
máxima siempre será el total de problemas multiplicado por asciimath:[5].

Por lo que la fórmula para calcular el total de tiempo dado un valor asciimath:[n] será: 

asciimath:[S_n = (n * (5 + (n * 5)))/2]

asciimath:[S_n = (5n + 5n^2)/2]

Tenemos el valor que tomará resolver asciimath:[n] cantidad de problemas, sin embargo 
debemos verificar que esto sea menor o igual al tiempo disponible. La pregunta a responder
es: ¿Cuál es el valor de asciimath:[x] cantidad de problemas de modo que sea menor o igual al tiempo disponible?.


asciimath:[S_n = (5x + 5x^2)/2 <= "disponible"] 

Multiplicamos por asciimath:[2] en ambos lados

asciimath:[S_n = (5x + 5x^2) <=  (2 * "disponible)"]


asciimath:[S_n = 5 * (x + x^2) <=  (2 * "disponible")]

asciimath:[S_n = x + x^2 <=  (2 * "disponible")/5]

Como asciimath:["disponible"] es un valor constante, obtenemos una ecuación cuadrática.

asciimath:[S_n = x^2 + x - (2 * "disponible")/5 <=  0]

Solo necesitamos despejar asciimath:[x] con la fórmula de ecuación 
cuadrática asciimath:[x=(-b +- sqrt(b^2 - 4ac))/(2a)].

Siendo los siguientes los valores a reemplazar en la ecuación:

- asciimath:[a = 1] (Coeficiente cuadrático asciimath:[x^2])
- asciimath:[b = 1] (Coeficiente lineal asciimath:[x])
- asciimath:[c = (2 * "disponible")/5] (Constante o término independiente).

Por lo que la ecuación quedan dos posibles resultados.

- Solución Positiva: asciimath:[x=(-1 + sqrt((-1)^2 - 4 * 1 * c))/(2*1)]
- Solución Negativa: asciimath:[x=(-1 - sqrt((-1)^2 - 4 * 1 * c))/(2*1)]

Como estamos contando minutos, estos no pueden ser negativos. Por lo que 
solamente consideramos con la *Solución Positiva*.

asciimath:[x=(-1 + sqrt((-1)^2 - 4 * 1 * c))/(2*1)]

asciimath:[x=(-1 + sqrt(1 - 4c))/2]

Reemplazamos asciimath:[c] por el valor "disponible"

asciimath:[x=(-1 + sqrt(1 - 4 * ((2 * "disponible")/5)))/2]

asciimath:[x=(-1 + sqrt(1 - (8 * "disponible")/5))/2]

Finalmente, la solución no puede ser mayor a la cantidad máxima asciimath:[n] de ejercicios
disponibles. Por lo que debemos aplicar una operación de límite máximo. Conocida como *clamp*
o *abrazadera* (`clamp(x, min, max)`).

asciimath:["respuesta" = min(max(x, 0), n)]


[source, cpp]
----
include::example$750a-new-year-hurry/solution-o(1).cpp[]
----

== Solución O(logn) en Python

La solución corresponde a encontrar la respuesta
utilizando búsqueda binaria entre todo el espectro de candidatos posibles (técnica de Binary Search in answer).

*Paso 1*

Sabemos que el tiempo máximo será de 4 horas - el tiempo que tome llegar a la fiesta. Es decir asciimath:[240 - k] minutos (siendo asciimath:[240] los minutos que tiene 4 horas). 

El desafío consiste en averiguar la cantidad máxima de problemas que se pueden resolver dentro del tiempo disponible.

[source, python]
----
def main():
    n, k = map(int, input().split())
    available_time = 240 - k
    print(find_max_quantity_of_solved_problems(n, available_time))

if __name__ == "__main__":
  main()
----

*Paso 2*

Ahora se obtiene el máximo y el mínimo dentro de la función que aplicará la búsqueda binaria. Estos vienen siendo la cantidad de problemas posibles a resolver. Como mínimo resolveremos cero y como máximo la cantidad total de problemas.

Notar que si el candidato es válido, tenemos que averiguar si el siguiente candidato es mejor (más problemas posibles a resolver).
Por lo que debemos aumentar el límite mínimo. Caso contrario
deberemos reducir el límite máximo.

[source, python]
----
def find_max_quantity_of_solved_problems(total_problem_count, available_time):
    low = 0
    high = total_problem_count

    answer = high

    while low <= high:
        candidate = low + (high - low) // 2

        if candidate_is_valid(candidate, available_time):
            answer = candidate
            low = candidate + 1
        else:
            high = candidate - 1
            
    return answer
----

*Paso 3*

Luego se define la función para validar el candidato. Si el tiempo total necesario para resolver la cantidad de problemas sugeridas por el candidato es menor al tiempo disponible, entonces es un candidato válido.
El range de asciimath:[i] es mínimo es asciimath:[1] y máximo la cantidad de soluciones del candidato + una adicional para compensar el contador desde cero.

[source, python]
----
def candidate_is_valid(quantity_to_solve, available_time):
  used_time = 0
  for i in range(1, quantity_to_solve + 1):
    used_time += i * 5
  return used_time <= available_time
----

*Solución*

Juntando todo el código se tiene la siguiente solución.

[source, python]
----
include::example$750a-new-year-hurry/solution-bs.py[]
----